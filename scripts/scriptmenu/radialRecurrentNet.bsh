import java.awt.geom.Point2D;
import java.util.*;
import org.simbrain.network.NetworkComponent;
import org.simbrain.network.connections.*;
import org.simbrain.network.core.*;
import org.simbrain.network.groups.*;
import org.simbrain.network.layouts.*;
import org.simbrain.network.networks.*;
import org.simbrain.network.neurons.*;
import org.simbrain.util.randomizer.*;
import org.simbrain.util.SimbrainConstants.Polarity;
import org.simbrain.util.math.*;
import org.simbrain.workspace.*;

//
// Recurrent network using radial. Manipulate the parameters to get a feel for how the 
// the connection type works. Run and activate nodes with the wand to see the resulting
// network dynamics.
//
{

    // Parameters 
    int NUM_NEURONS = 144;
    double GRID_SPACE = 50;
    double EE_CONST = 0.3;
    double EI_CONST = 0.2;
    double IE_CONST = 0.5;
    double II_CONST = 0.1;
    double LAMBDA = 250; // Use this to modulate distance of interaction.

    // Build Network
    NetworkComponent networkComponent = new NetworkComponent("Network");
    workspace.addWorkspaceComponent(networkComponent);
    Network network = networkComponent.getNetwork();
    GridLayout layout = new GridLayout(GRID_SPACE, GRID_SPACE, (int) Math.sqrt(NUM_NEURONS));
    layout.setInitialLocation(new Point(10, 10));
    List<Neuron> neurons = new ArrayList<Neuron>(NUM_NEURONS);
    for (int i = 0; i < NUM_NEURONS; i++) {
        Neuron neuron = new Neuron(network, "NakaRushtonRule");
        neuron.setUpperBound(100);
        neurons.add(neuron);
        if (i % 4 == 0) {
        	neuron.setPolarity(Polarity.INHIBITORY);
        } else {
        	neuron.setPolarity(Polarity.EXCITATORY);
        }
    }
    NeuronGroup ng1 = new NeuronGroup(network, neurons);
    network.addGroup(ng1);
    ng1.setLayout(layout);
    ng1.applyLayout(new Point2D.Double(0.0 ,0.0));

	PolarizedRandomizer exRand = new PolarizedRandomizer(Polarity.EXCITATORY,
		ProbDistribution.LOGNORMAL);
	PolarizedRandomizer inRand = new PolarizedRandomizer(Polarity.INHIBITORY,
		ProbDistribution.LOGNORMAL);
	exRand.setParam1(2);
	inRand.setParam1(3.0);	

	Radial rCon = new Radial(EE_CONST, EI_CONST, IE_CONST, II_CONST, LAMBDA);
	SynapseGroup sg = SynapseGroup.createSynapseGroup(ng1, ng1, rCon, 0.5, exRand, inRand);
	network.addGroup(sg);

    print(sg.size());
    sg.setUpperBound(70, Polarity.EXCITATORY);
    sg.setLowerBound(-70, Polarity.INHIBITORY);
    network.randomizeNeurons();
    network.fireSynapsesUpdated();

}
